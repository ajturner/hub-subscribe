import{A as t}from"./p-c5919bc3.js";import{H as e}from"./p-1458dcfd.js";import{c as s}from"./p-b728aff4.js";import{h as r}from"./p-b1a98ae3.js";import{l as i,J as o}from"./p-85d6867e.js";import{s as n}from"./p-4a14259a.js";import{i as a}from"./p-59fd2498.js";import{a as c}from"./p-cea8413b.js";import{m as h}from"./p-8dbea197.js";class u{constructor(t,e){this._collection=t,this._context=e}static fromJson(t,e){return new u(t,e)}toJson(){return s(this._collection)}get label(){return this._collection.label}get key(){return this._collection.key}get include(){return this._collection.include||[]}get scope(){return this._collection.scope}get sortField(){return this._collection.sortField||"title"}get sortDirection(){return this._collection.sortDirection||"asc"}get targetEntity(){return this._collection.targetEntity}async search(t,e={}){let i;i="string"==typeof t?{targetEntity:this._collection.targetEntity,filters:[{predicates:[{term:t}]}]}:t,i.filters=[...i.filters,...this.scope.filters];const o=s(e);return o.requestOptions=this._context.hubRequestOptions,o.sortField=e.sortField||this.sortField,o.sortOrder=e.sortOrder||this.sortDirection,o.include=e.include||this.include,r(i,o)}}class l{constructor(t,e){this._containsCache={},this._catalog=t,this._context=e}static async init(s,r){r||(r=(await t.create()).context);const h=await async function(t,s){let r;if(0===t.indexOf("http")){let e=t;e=n(e),e.includes("#")||(e=e.split("/")[0]),r=i(e,s).then((({siteId:t})=>c(t,s))).then((t=>o(t.catalog||{})))}else{if(!a(t))throw new e("Catalog.create","Identifier must be a url, guid");r=c(t,s).then((t=>o(t.catalog||{})))}return await r}(s,r.hubRequestOptions);return new l(h,r)}static fromJson(t,e){const s=o(t);return new l(s,e)}toJson(){return s(this._catalog)}get schemaVersion(){return this._catalog.schemaVersion}get title(){return this._catalog.title}set title(t){this._catalog.title=t}get scopes(){return this._catalog.scopes}get availableScopes(){return Object.keys(this.scopes)}getScope(t){return this._catalog.scopes[t]}setScope(t,e){this._catalog.scopes[t]=e}get collections(){return this._catalog.collections||[]}get collectionNames(){return h("key",this.collections)}getCollection(t){const e=this.getCollectionJson(t);return u.fromJson(e,this._context)}getCollectionJson(t){const r=this.collections.find((e=>e.key===t));if(r){const t=s(r),e=this.getScope(t.scope.targetEntity);return(null==e?void 0:e.filters)&&(t.scope.filters=[...t.scope.filters,...e.filters]),t}throw new e("getCollectionJson",`Collection "${t}" is not present in the Catalog`)}getCustomCollection(t,e){const s=this.getCustomCollectionJson(t,e);return u.fromJson(s,this._context)}getCustomCollectionJson(t,e){const s=this.getScope(t);return{key:`${t}-custom`,label:`${t} Custom`,targetEntity:t,scope:{targetEntity:t,filters:[...(null==s?void 0:s.filters)||[],...e]}}}async searchItems(t,e){if(e||(e=this.getDefaultSearchOptions("item")),this.getScope("item"))return e.targetEntity="item",this.search(t,e);{const t=this.getEmptyResult();return t.messages=[{code:"missingScope",message:"Catalog does not have a scope for items",data:{scope:"item"}}],Promise.resolve(t)}}async contains(t,e){const r=Date.now(),i=this._catalog;if(this._containsCache[t]){const e=s(this._containsCache[t]);return e.duration=Date.now()-r,Promise.resolve(e)}{const s={identifier:t,isContained:!1},o={};a(t)?o.id=t:o.typekeywords=`slug|${t}`;const n=[];if(e.entityType){if(!this.scopes[e.entityType])return s.duration=Date.now()-r,this._containsCache[t]=s,Promise.resolve(s);n.push({targetEntity:e.entityType,filters:[{predicates:[o]}]})}else Object.keys(i.scopes).forEach((t=>{n.push({targetEntity:t,filters:[{predicates:[o]}]})}));const c=await Promise.all(n.map((t=>this.search(t,{targetEntity:t.targetEntity,num:10}))));return s.isContained=c.reduce(((t,e)=>(e.results.length&&(t=!!o.id||e.results.reduce(((t,e)=>(e.typeKeywords.includes(o.typekeywords)&&(t=!0),t)),!1)),t)),!1),s.duration=Date.now()-r,this._containsCache[t]=s,s}}async searchGroups(t,e){if(e||(e=this.getDefaultSearchOptions("group")),this.getScope("group"))return e.targetEntity="group",this.search(t,e);{const t=this.getEmptyResult();return t.messages=[{code:"missingScope",message:"Catalog does not have a scope for groups",data:{scope:"group"}}],Promise.resolve(t)}}async searchUsers(t,e={}){if(this.getScope("user"))return e.targetEntity="user",this.search(t,e);{const t=this.getEmptyResult();return t.messages=[{code:"missingScope",message:"Catalog does not have a scope for user",data:{scope:"user"}}],Promise.resolve(t)}}async searchCollections(t,e={}){const s={targetEntity:"item",filters:[{predicates:[{term:t}]}]},r=[],i=this.collectionNames.map((t=>{const i=this.getCollection(t);return r.push(t),s.targetEntity=i.targetEntity,i.search(s,e)})),o=await Promise.all(i),n={};for(let t=0;t<r.length;t++)n[r[t]]=o[t];return n}async searchScopes(t,e={}){const r={targetEntity:"item",filters:[{predicates:[{term:t}]}]},i=[],o=this.availableScopes.map((t=>{i.push(t);const o=s(r),n=s(e);return o.targetEntity=t,n.targetEntity=t,this.search(o,n)})),n=await Promise.all(o),a={};for(let t=0;t<i.length;t++)a[i[t]]=n[t];return a}async search(t,e){const i=e.targetEntity;let o;o="string"==typeof t?{targetEntity:i,filters:[{predicates:[{term:t}]}]}:s(t),o.filters=[...o.filters,...this.getScope(i).filters];const n=s(e);return delete n.authentication,n.requestOptions=this._context.hubRequestOptions,r(o,n)}getEmptyResult(){return{results:[],total:0,hasNext:!1,next:null}}getDefaultSearchOptions(t){return{targetEntity:t,num:10,start:1,requestOptions:this._context.hubRequestOptions}}}export{l as C}